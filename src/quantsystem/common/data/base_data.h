/*
 * \copyright Copyright 2015 All Rights Reserved.
 * \license @{
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @}
 */

/**
 * @defgroup CommonBaseData Common - Base Data Components
 * 
 * Base data components of Quantsystem.
 */
#ifndef QUANTSYSTEM_COMMON_BASE_DATA_H_
#define QUANTSYSTEM_COMMON_BASE_DATA_H_

#include <string>
using std::string;
#include "quantsystem/common/time/date_time.h"
#include "quantsystem/common/global.h"
#include "quantsystem/common/strings/stringpiece.h"
#include "quantsystem/common/data/subscription_data_config.h"

namespace quantsystem {
namespace data {
class SubscriptionDataConfig;
/**
 * Abstract base data of Quantsystem.
 * @ingroup CommonBaseData
 * 
 * It is intended to be extended to define generic user
 * customizable data types while at the same time implementing
 * the basics of data where possible
 */
class BaseData {
 public:
  /**
   * Standard constructor.
   */
  BaseData();

  /**
   * Copy constructor.
   */
  BaseData(const BaseData& data);

  /**
   * Standard destructor.
   */
  virtual ~BaseData();

  /**
   * Set the data type.
   *
   * @param data_type Market data type of this data.
   */
  void set_data_type(const MarketDataType::Enum& data_type) {
    data_type_ = data_type;
  }

  /**
   * Return the data type.
   */
  MarketDataType::Enum data_type() const { return data_type_; }

  /**
   * Set the current time marker of this data packet.
   *
   * @param time Time of this data packet.
   */
  void set_time(const DateTime& time) { time_ = time; }

  /**
   * Return the current time marker of this data packet.
   */
  const DateTime& time() const { return time_; }

  DateTime time() { return time_; }

  /**
   * Set the symbol.
   *
   * @param symbol Symbol of underlying security.
   */
  void set_symbol(const StringPiece& symbol) { symbol_ = symbol.as_string(); }

  /**
   * Return the symbol.
   */
  const string& symbol() const {return symbol_; }

  /**
   * Set the value of this data packet.
   *
   * @param value Value of this data packet.
   */
  void set_value(const double& value) { value_ = value; }

  /**
   * Return the value of this data packet.
   */
  double value() const { return value_; }

  /**
   * Alias of value as price.
   */
  double Price() const { return value_; }

  /**
   * Convert data source into BaseData objects.
   *
   * Reader converts each line of the data source into BaseData objects.
   * Each data type creates its own factory method,
   * and returns a new instance of the object each time it is called.
   *
   * @param config Subscription data config setup object.
   * @param line Line of the source document.
   * @param date Date of the requested data.
   * @param datafeed Type of datafeed - a live or backtest feed.
   * @return Instance of BaseData object generated by this line of the CSV.
   */
  virtual BaseData* Reader(const SubscriptionDataConfig& config,
                          const StringPiece& line, const DateTime& date,
                           DataFeedEndpoint::Enum datafeed) = 0;

  /**
   * Get the URL stirng souce of the file.
   *
   * Return the URL string source of the file.
   * This will be converted to a stream.
   *
   * @param config Configuration object.
   * @param date Date of this souce file.
   * @param data_feed Type of datafeed - a live or backtest feed.
   * @retrurn URL of source file.
   */
  virtual string GetSource(const SubscriptionDataConfig& config,
                           const DateTime& date,
                           DataFeedEndpoint::Enum data_feed) = 0;

  /**
   * Update routine to build a bar/tick from a data update.
   *
   * @param last_trade The last trade price.
   * @param bid_price Current bid price.
   * @param ask_price Current asking price.
   * @param volume Current volume price.
   */
  virtual void Update(const double& last_trade, const double &bid_price,
                 const double& ask_price, const double& volume) {
    value_ = last_trade;
  }

  /**
   * Return a new instance clone of this object.
   *
   * @return A new instance clone of this object.
   */
  virtual BaseData* Clone() const {
  }

 private:
  // Market Data Type of this data - does it come in individual
  // price packets or is it grouped into OHLC.
  MarketDataType::Enum data_type_;
  // Current time marker of this data packet.
  DateTime time_;
  // String symbol representation for underlying Security.
  string symbol_;
  // Value representation of this data packet.
  // All data requires a representative value for this moment in time.
  double value_;
};

}  // namespace data
}  // namespace quantsystem
#endif  // QUANTSYSTEM_COMMON_BASE_DATA_H_
